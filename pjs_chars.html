<!DOCTYPE html>
<html>
<head>
  <script src="processing.js"></script>
  <script src="traer.physics.js"></script>
  <script src="init.js"></script>
<link rel="stylesheet" href="style.css"/></head>
<body>
<script type="application/processing">

ParticleSystem physics;

Particle p;
Spring s;
Body b, b2;
Body[] bodies;

void setup()
{
  size( 800, 800 );
  smooth();
  fill( 0 );
  ellipseMode( CENTER );
  
  physics = new ParticleSystem( 0, 0.04 );
  //physics.setIntegrator(ParticleSystem.MODIFIED_EULER);      
  // physics.makeSpring(b.ne, anchor, 0.5, 0.4, 75);
  // s = physics.makeSpring( p, anchor, 0.5, 0.4, 75 );
  bodies = new Body[5];
  for (var i = bodies.length - 1; i >= 0; i--) {
    len = ceil(random()*3)+2;
    console.log(len);
    bodies[i] = new Body(len, noise(i, i)*width, noise(i, i)*height);
  };
}

void mousePressed()
{
}

void mouseDragged()
{
}

void mouseReleased()
{
}

void draw()
{
  physics.tick();
  background( 255 );
  for (var i = bodies.length - 1; i >= 0; i--) {
    bodies[i].draw();
  };  
  update();
}
void update()
{
  for (var i = bodies.length - 1; i >= 0; i--) {
    bodies[i].update();
  };  
}
// apparently the preprocessor is a little bit wierd, but we should be able to do this type of thing

// the body connects together a bunch of segments
class Body{
  BodySegment[] segments;
  Particle anchor;
  float p1, p2;
  Body(int numSegments, float x, float y){

    anchor = physics.makeParticle( 1.0, x, y, 0 );
    anchor.makeFixed(); 

    // temp vars
    w = 10;
    h = 40;

    segSpace = 20;
    segments = new BodySegment[numSegments];
    for (var i = 0; i < numSegments; i++) {
      segments[i] = new BodySegment(width/2, h*i, w+sin(i/numSegments*TWO_PI)*w+w, h);
      // connect the new segment to the previous segment
      if(i>0){
        physics.makeSpring(segments[i-1].se, segments[i].ne, 0.1, 0.5, segSpace);
          physics.makeSpring(segments[i-1].sw, segments[i].nw, 0.1, 0.5, segSpace);
      }
    };

    // connect the head of the body to the anchor
    physics.makeSpring(segments[0].ne, anchor, 0.1, 0.4, 75);
    physics.makeSpring(segments[0].nw, anchor, 0.1, 0.4, 75);

    // the period for running the animation
    p1 = 100 + (random()*2-1) * 50;
    p2 = 1000 + (random()*2-1) * 500;
  }

  void draw(){
    for (var i = 0; i < segments.length; i++) {
      segments[i].draw();
      if(i>0){
        quad(
          segments[i-1].se.position().x(),segments[i-1].se.position().y(),
          segments[i-1].sw.position().x(),segments[i-1].sw.position().y(),
          segments[i].nw.position().x(),segments[i].nw.position().y(),
          segments[i].ne.position().x(),segments[i].ne.position().y()
        );
      }
    }    
  }
  void update(){
    anchor.position().set( (sin(millis()/p1)*40+sin(millis()/p2)*400)+width/2, (sin(millis()/300)*30+sin(millis()/1000)*300)+width/2, 0 );
  }
}

class BodySegment{
  float x, y, w, h;
  Particle ne, se, nw, sw;
  Spring n, e, s, west;
  BodySegment(float _x, float _y, float _w, float _h){
    x = _x;
    y = _y;
    w = _w;
    h = _h;
    ne = physics.makeParticle(1.0, x+w/2, y+h/2, 0);
    nw = physics.makeParticle(1.0, x-w/2, y+h/2, 0);
    se = physics.makeParticle(1.0, x+w/2, y-h/2, 0);
    sw = physics.makeParticle(1.0, x-w/2, y-h/2, 0);
    n = physics.makeSpring(ne, nw, 0.5, 0.4, w);
    e = physics.makeSpring(ne, se, 0.5, 0.4, h);
    s = physics.makeSpring(se, sw, 0.5, 0.4, w);
    west = physics.makeSpring(sw, nw, 0.5, 0.4, h);

    // we also need crossbars to keep everything from flipping out
    physics.makeSpring(ne, sw, 0.01, 0.15, sqrt(sq(w)+sq(h)))
    physics.makeSpring(nw, se, 0.01, 0.15, sqrt(sq(w)+sq(h)))
  }
  void draw(){
    // clockwise
    quad(
      se.position().x(),se.position().y(), sw.position().x(),sw.position().y(),nw.position().x(),nw.position().y(),ne.position().x(),ne.position().y())
    // ellipse(ne.position().x(),ne.position().y(),5,5);
    // ellipse(nw.position().x(),nw.position().y(),5,5);
    // ellipse(se.position().x(),se.position().y(),5,5);
    // ellipse(sw.position().x(),sw.position().y(),5,5);
  }
}


</script>
<canvas width="200" height="200"></canvas>
<div style="height:0px;width:0px;overflow:hidden;"></div>

</body>
</html>
