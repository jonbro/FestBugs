<!DOCTYPE html>
<html>
<head>
  <script src="processing.js"></script>
  <script src="traer.physics.js"></script>
  <script src="Box2dWeb-2.1.a.3.js"></script>
  <script src="init.js"></script>
<link rel="stylesheet" href="style.css"/></head>
<body>
<script type="application/processing">

ParticleSystem physics;

Particle p;
Spring s;
Body body;
var b2Vec2 = Box2D.Common.Math.b2Vec2
  , b2AABB = Box2D.Collision.b2AABB
  , b2BodyDef = Box2D.Dynamics.b2BodyDef
  , b2Body = Box2D.Dynamics.b2Body
  , b2FixtureDef = Box2D.Dynamics.b2FixtureDef
  , b2Fixture = Box2D.Dynamics.b2Fixture
  , b2World = Box2D.Dynamics.b2World
  , b2MassData = Box2D.Collision.Shapes.b2MassData
  , b2PolygonShape = Box2D.Collision.Shapes.b2PolygonShape
  , b2CircleShape = Box2D.Collision.Shapes.b2CircleShape
  , b2DebugDraw = Box2D.Dynamics.b2DebugDraw
  , b2MouseJointDef =  Box2D.Dynamics.Joints.b2MouseJointDef
  , b2DistanceJointDef =  Box2D.Dynamics.Joints.b2DistanceJointDef
  , b2Math = Box2D.Common.Math.b2Math
  ;

var world = new b2World(
     new b2Vec2(0, 20)    //gravity
  ,  true                 //allow sleep
);
var selectedBody, mouseJoint;
var ratio = 30; // for converting box2d units to display and vice versa
var doSleep = true;
var timeStep = 1.0/30;
var iteration = 12;
         var debugDraw = new b2DebugDraw();
      debugDraw.SetSprite(document.getElementById("canvas").getContext("2d"));
      debugDraw.SetDrawScale(30.0);
      debugDraw.SetFillAlpha(0.5);
      debugDraw.SetLineThickness(1.0);
      debugDraw.SetFlags(b2DebugDraw.e_shapeBit | b2DebugDraw.e_jointBit);
      world.SetDebugDraw(debugDraw);

void setup()
{
  size( 800, 800 );
  smooth();
  fill( 0 );
  ellipseMode( CENTER );
  body = new Body();

  // create the view box, so we don't lose stuff
  // off the screen
  var fixDef = new b2FixtureDef;
  fixDef.density = 1.0;
  fixDef.friction = 0.5;
  fixDef.restitution = 0.2;
  var bodyDef = new b2BodyDef;
  bodyDef.type = b2Body.b2_staticBody;
  fixDef.shape = new b2PolygonShape;
  fixDef.shape.SetAsBox(20, 2);
  bodyDef.position.Set(10, 400 / 30 + 1.8);
  world.CreateBody(bodyDef).CreateFixture(fixDef);
  bodyDef.position.Set(10, -1.8);
  world.CreateBody(bodyDef).CreateFixture(fixDef);
  fixDef.shape.SetAsBox(2, 14);
  bodyDef.position.Set(-1.8, 13);
  world.CreateBody(bodyDef).CreateFixture(fixDef);
  bodyDef.position.Set(21.8, 13);
  world.CreateBody(bodyDef).CreateFixture(fixDef);

}

void mousePressed()
{
}

void mouseDragged()
{
}

void mouseReleased()
{
}

void draw()
{
  background(255);
  body.draw();
  update();
  world.Step(1 / 60, 10, 10);
              world.DrawDebugData();

  world.ClearForces();
}
b2Body getBodyAtMouse() {
  mousePVec = new b2Vec2(mouseX/30, mouseY/30);
  var aabb = new b2AABB();
  aabb.lowerBound.Set(mouseX/30 - 0.001, mouseY/30 - 0.001);
  aabb.upperBound.Set(mouseX/30 + 0.001, mouseY/30 + 0.001);
  
  // Query the world for overlapping shapes.
  //console.log(mouseX/30, mouseY/30, aabb)
  selectedBody = null;
  world.QueryAABB(function(fixture) {
    console.log(fixture);
    if(fixture.GetBody().GetType() != b2Body.b2_staticBody) {
       if(fixture.GetShape().TestPoint(fixture.GetBody().GetTransform(), mousePVec)) {
          selectedBody = fixture.GetBody();
          return false;
       }
    }
    return true;
  }, aabb);
  return selectedBody;
}


void update() {

  if(mousePressed && (!mouseJoint)) {
     var body = getBodyAtMouse();
     if(body) {
        var md = new b2MouseJointDef();
        md.bodyA = world.GetGroundBody();
        md.bodyB = body;
        md.target.Set(mouseX/30, mouseY/30);
        md.collideConnected = true;
        md.maxForce = 300.0 * body.GetMass();
        mouseJoint = world.CreateJoint(md);
        body.SetAwake(true);
     }
  }
  
  if(mouseJoint) {
     if(mousePressed) {
        mouseJoint.SetTarget(new b2Vec2(mouseX/30, mouseY/30));
        //mouseJoint.SetTarget(new b2Vec2(mouseX, mouseY));
     } else {
        world.DestroyJoint(mouseJoint);
        mouseJoint = null;
     }
  }

};


void drawShape(shape,body) {
  poly = shape;
  beginShape();
  for (var i = 0; i < poly.m_vertexCount; i++) {
    b2Vec2 v = b2Math.MulMV(body.GetTransform().R, poly.GetVertices()[i]);
    v = b2Math.AddVV(v, body.GetWorldCenter());
    vertex(v.x*ratio, v.y*ratio);
  }
  endShape();
}

// apparently the preprocessor is a little bit wierd, but we should be able to do this type of thing
class BodySegment{
  float x, y, w, h;
  b2FixtureDef fixDef;
  b2BodyDef body;
  b2Body wbody;
  BodySegment(float _x, float _y, float _w, float _h){
    x = _x;
    y = _y;
    w = _w;
    h = _h;
    
    fixDef = new b2FixtureDef();
    fixDef.density = 1.0;
    fixDef.friction = 0.5;
    fixDef.restitution = 0.2;

    // the shape definition
    fixDef.shape = new b2PolygonShape;
    fixDef.shape.SetAsBox(
      w/2,
      h/2
    );
    // the body definition
    body = new b2BodyDef();
    body.type = b2Body.b2_dynamicBody;

    body.position.Set(x,y);

    // the body in the world, I don't know the diff between this and the main body def
    wbody = world.CreateBody(body);
    wbody.CreateFixture(fixDef);
  }

  void draw(){
      drawShape(fixDef.shape, wbody);
  }
}

class Body{
  BodySegment[] seg;
  b2MouseJoint mouseJoint;
  Body(){
    seg = new BodySegment[5];
    for (var i = 0; i < seg.length; i++) {
      seg[i] = new BodySegment(0*30, (i*20)/30, 20/30, 20/30);
      if(i>0){
        joint = new b2DistanceJointDef();
        joint.Initialize(seg[i-1].wbody, seg[i].wbody, seg[i-1].wbody.GetWorldCenter(), seg[i].wbody.GetWorldCenter());
        world.CreateJoint(joint);
      }
    };
    //attach the body to a joint so that we can chuck it around
    var bControlDef = new b2MouseJointDef();
    bControlDef.bodyA = world.GetGroundBody();
    bControlDef.bodyB = seg[0].wbody;

    bControlDef.target.Set(seg[0].wbody.GetPosition().x, seg[0].wbody.GetPosition().y);
    bControlDef.collideConnected = true;
    bControlDef.maxForce = 300.0 * seg[0].wbody.GetMass();
    mouseJoint = world.CreateJoint(bControlDef);

  }
  void draw(){
    for (var i = seg.length - 1; i >= 0; i--) {
      seg[i].draw();
    };
    // mouseX = mouseX/ratio;
    // mouseY = mouseY/ratio;
    //console.log(sin(millis()/100)*width/ratio+(width/ratio));
    // console.log(mouseX, mouseY);
    if(mouseX/30 > 0 && mouseY/30 > 0)
       mouseJoint.SetTarget(new b2Vec2(mouseX/30, mouseY/30));
  }
}

</script>
<canvas width="200" height="200"></canvas>
<canvas id="canvas" width="600" height="400" style="background-color:#333333;" ></canvas>
<div style="height:0px;width:0px;overflow:hidden;"></div>

</body>
</html>
