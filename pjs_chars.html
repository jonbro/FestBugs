<!DOCTYPE html>
<html>
<head>
  <script src="processing.js"></script>
  <script src="traer.physics.js"></script>
  <script src="Box2dWeb-2.1.a.3.js"></script>
  <script src="init.js"></script>
<link rel="stylesheet" href="style.css"/></head>
<body>
<script type="application/processing">

ParticleSystem physics;

Particle p;
Spring s;
Body body;
var b2Vec2 = Box2D.Common.Math.b2Vec2
  , b2AABB = Box2D.Collision.b2AABB
  , b2BodyDef = Box2D.Dynamics.b2BodyDef
  , b2Body = Box2D.Dynamics.b2Body
  , b2Shape = Box2D.Collision.Shapes.b2Shape
  , b2FixtureDef = Box2D.Dynamics.b2FixtureDef
  , b2Fixture = Box2D.Dynamics.b2Fixture
  , b2World = Box2D.Dynamics.b2World
  , b2MassData = Box2D.Collision.Shapes.b2MassData
  , b2PolygonShape = Box2D.Collision.Shapes.b2PolygonShape
  , b2CircleShape = Box2D.Collision.Shapes.b2CircleShape
  , b2DebugDraw = Box2D.Dynamics.b2DebugDraw
  , b2MouseJointDef =  Box2D.Dynamics.Joints.b2MouseJointDef
  , b2DistanceJointDef =  Box2D.Dynamics.Joints.b2DistanceJointDef
  , b2Math = Box2D.Common.Math.b2Math
  ;

var world = new b2World(
     new b2Vec2(0, 20)    //gravity
  ,  true                 //allow sleep
);
var selectedBody, mouseJoint;
var ratio = 30; // for converting box2d units to display and vice versa
var doSleep = true;
var timeStep = 1.0/30;
var iteration = 12;
         var debugDraw = new b2DebugDraw();
      debugDraw.SetSprite(document.getElementById("canvas").getContext("2d"));
      debugDraw.SetDrawScale(30.0);
      debugDraw.SetFillAlpha(0.5);
      debugDraw.SetLineThickness(1.0);
      debugDraw.SetFlags(b2DebugDraw.e_shapeBit | b2DebugDraw.e_jointBit);
      world.SetDebugDraw(debugDraw);

void setup()
{
  size( 800, 800 );
  smooth();
  fill( 0 );
  ellipseMode( CENTER );
  body = new Body();

  // create the view box, so we don't lose stuff
  // off the screen
  var fixDef = new b2FixtureDef;
  fixDef.density = 1.0;
  fixDef.friction = 0.5;
  fixDef.restitution = 0.2;
  var bodyDef = new b2BodyDef;
  bodyDef.type = b2Body.b2_staticBody;
  fixDef.shape = new b2PolygonShape;
  fixDef.shape.SetAsBox(20, 2);
  bodyDef.position.Set(10, 400 / 30 + 1.8);
  world.CreateBody(bodyDef).CreateFixture(fixDef);
  bodyDef.position.Set(10, -1.8);
  world.CreateBody(bodyDef).CreateFixture(fixDef);
  fixDef.shape.SetAsBox(2, 14);
  bodyDef.position.Set(-1.8, 13);
  world.CreateBody(bodyDef).CreateFixture(fixDef);
  bodyDef.position.Set(21.8, 13);
  world.CreateBody(bodyDef).CreateFixture(fixDef);

}

void mousePressed()
{
}

void mouseDragged()
{
}

void mouseReleased()
{
}

void draw()
{
  background(255);
  body.draw();
  update();
  world.Step(1 / 60, 10, 10);
              world.DrawDebugData();

  world.ClearForces();
}
b2Body getBodyAtMouse() {
  mousePVec = new b2Vec2(mouseX/30, mouseY/30);
  var aabb = new b2AABB();
  aabb.lowerBound.Set(mouseX/30 - 0.001, mouseY/30 - 0.001);
  aabb.upperBound.Set(mouseX/30 + 0.001, mouseY/30 + 0.001);
  
  // Query the world for overlapping shapes.
  //console.log(mouseX/30, mouseY/30, aabb)
  selectedBody = null;
  world.QueryAABB(function(fixture) {
    console.log(fixture);
    if(fixture.GetBody().GetType() != b2Body.b2_staticBody) {
       if(fixture.GetShape().TestPoint(fixture.GetBody().GetTransform(), mousePVec)) {
          selectedBody = fixture.GetBody();
          return false;
       }
    }
    return true;
  }, aabb);
  return selectedBody;
}


void update() {

  if(mousePressed && (!mouseJoint)) {
     var body = getBodyAtMouse();
     if(body) {
        var md = new b2MouseJointDef();
        md.bodyA = world.GetGroundBody();
        md.bodyB = body;
        md.target.Set(mouseX/30, mouseY/30);
        md.collideConnected = true;
        md.maxForce = 300.0 * body.GetMass();
        mouseJoint = world.CreateJoint(md);
        body.SetAwake(true);
     }
  }
  
  if(mouseJoint) {
     if(mousePressed) {
        mouseJoint.SetTarget(new b2Vec2(mouseX/30, mouseY/30));
        //mouseJoint.SetTarget(new b2Vec2(mouseX, mouseY));
     } else {
        world.DestroyJoint(mouseJoint);
        mouseJoint = null;
     }
  }

};


void drawShape(shape,body) {
  switch(shape.m_type){
    case b2Shape.e_circleShape:
      var center = b2Math.MulX(body.m_xf, shape.m_p);
      var radius = shape.m_radius;
      ellipse(center.x*ratio, center.y*ratio, radius*ratio*2, radius*ratio*2);
    case b2Shape.e_polygonShape:
      poly = shape;
      // console.log(shape.GetType())
      beginShape();
      for (var i = 0; i < poly.m_vertexCount; i++) {
        b2Vec2 v = b2Math.MulMV(body.GetTransform().R, poly.GetVertices()[i]);
        v = b2Math.AddVV(v, body.GetWorldCenter());
        vertex(v.x*ratio, v.y*ratio);
      }
      endShape();
      break;
  }
}

// apparently the preprocessor is a little bit wierd, but we should be able to do this type of thing
class BodySegment{
  float x, y, w, h;
  b2Body ne, se, sw, nw;
  b2DistanceJoint n, s, e, west;

  BodySegment(float _x, float _y, float _w, float _h){
    x = _x;
    y = _y;
    w = _w;
    h = _h;
    ne = createNode(x+w/2, y-h/2, 10);
    nw = createNode(x-w/2, y-h/2, 10);
    se = createNode(x+w/2, y+h/2, 10);
    sw = createNode(x-w/2, y+h/2, 10);
    // set up all the distance joints that will keep the segments apart
    //n
    sideDamp = 0.3;
    n     = createJoint(ne, nw, sideDamp);
    e     = createJoint(ne, se, sideDamp);
    s     = createJoint(sw, se, sideDamp);
    west  = createJoint(sw, nw, sideDamp);
    console.log(west.GetDampingRatio());
    // create the cross joints
    createJoint(ne, sw, 0.005);
    createJoint(nw, se, 0.005);
  }
  void draw(){
    drawShape(ne.shape, ne);
    drawShape(nw.shape, nw);
    drawShape(se.shape, se);
    drawShape(sw.shape, sw);
  }
  void createNode(x, y, r){
    fixDef = new b2FixtureDef();
    fixDef.density = 1.0;
    fixDef.friction = 0.5;
    fixDef.restitution = 0.2;
    // the shape definition
    fixDef.shape = new b2CircleShape(
      r/2/ratio //radius
    );
    // the body definition
    bodyDef = new b2BodyDef();
    bodyDef.type = b2Body.b2_dynamicBody;
    bodyDef.position.Set(x,y);
    // the body in the world, I don't know the diff between this and the main body def
    body = world.CreateBody(bodyDef);
    body.CreateFixture(fixDef);
    body.shape = fixDef.shape;
    return body;
  }
}
void createJoint(a, b, d){
  joint = new b2DistanceJointDef();
  joint.Initialize(a, b, a.GetWorldCenter(), b.GetWorldCenter());
  joint.dampingRatio = d;
  joint.frequencyHz = 6.0;
  return world.CreateJoint(joint);
}

class Body{
  BodySegment[] seg;
  b2MouseJoint mouseJoint;
  Body(){
    seg = new BodySegment[5];
    for (var i = 0; i < seg.length; i++) {
      seg[i] = new BodySegment(10/30, (i*30)/30, 20/30, 20/30);
      // connect the body segments
      if(i>0){
        createJoint(seg[i].ne, seg[i-1].se, 0.9);
        createJoint(seg[i].nw, seg[i-1].sw, 0.9);
        // and crossbars
        createJoint(seg[i].ne, seg[i-1].sw, 0.9);
        createJoint(seg[i].nw, seg[i-1].se, 0.9);
      }
    };
    // //attach the body to a joint so that we can chuck it around
    // var bControlDef = new b2MouseJointDef();
    // bControlDef.bodyA = world.GetGroundBody();
    // bControlDef.bodyB = seg[0].wbody;

    // bControlDef.target.Set(seg[0].wbody.GetPosition().x, seg[0].wbody.GetPosition().y);
    // bControlDef.collideConnected = true;
    // bControlDef.maxForce = 300.0 * seg[0].wbody.GetMass();
    // mouseJoint = world.CreateJoint(bControlDef);

  }
  void draw(){
    for (var i = seg.length - 1; i >= 0; i--) {
      seg[i].draw();
    };
    // mouseX = mouseX/ratio;
    // mouseY = mouseY/ratio;
    //console.log(sin(millis()/100)*width/ratio+(width/ratio));
    // console.log(mouseX, mouseY);
    // if(mouseX/30 > 0 && mouseY/30 > 0)
    //    mouseJoint.SetTarget(new b2Vec2(mouseX/30, mouseY/30));
  }
}

</script>
<canvas width="200" height="200"></canvas>
<canvas id="canvas" width="600" height="400" style="background-color:#333333;" ></canvas>
<div style="height:0px;width:0px;overflow:hidden;"></div>

</body>
</html>
